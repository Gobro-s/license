# 1. 서버 아키텍쳐

## 1. 서버 아키텍처란?
- 클라이언트 - 서버 구조로 모든 비지니스 개발을 서버에서 하게 됐으므로 서버 아키텍처에 대한 이해가 필요하다.
- 클라이언트 서버 구조
	- 클라이언트는 서버에서 분리되어 있고, 각각의 클라이언트는 서버에 요청하는 방식
	- 서버의 유형은 애플리케이션 서버, 파일 및 FTP 서버, 터미널 서버, 메일, DNS 서버, 등으로 구분
|구분|역할|기능|
|--|--|--|
|서버|수동적, 서비스 제공자<br>(Passiv, Slave)|- 클라이언트 요청을 처리하기 위해 대기<br>- 요청을 처리한 후, 결과를 클라이언트에 회신하는 역할(Reply)|
|클라이언트|능동적, 의뢰자<br>(Active, Master)|- 서버가 수행할 수 있는 요청을 전송하는 역할 <br> - 회신(응답)이 반환될 때까지 기다리는 행위 진행|

## 2. N계층 서버 아키텍처 변화
- 인터넷 기반의 2계층 서비스에서 애플리케이션 서버가 추가된 3계층 서비스로 아키텍처가 변화, 3계층 구조는 2계층과 달리 Client와 DB 사이에 비즈니스 처리를 전담하는 애플리케이션 서버를 통하여 비즈니스 개발 부분을 분리
|2계층 구조| Client --> LAN(TCP/IP) ---> DataBase Server|
|--|--|
|3계층 구조|Client --> LAN(TCP/IP) --> Application Server --> Database Server|

- 웹 브라우저로 전송되는 정적인 콘텐츠 (CSS, 이미지, 스크립트)는 Web Server에서 전담하는 역할
- 비지니스 전담 서블릿 등의 컴포넌트는 WAS(Web Application Server)에 설치해 아키텍처 구성
|사용자| → | Web Browser(Web Client)|→<br>HTTP요청|Web Server|→<br>비지니스 요청|Web Application Server|→<br>DB 조회| DB|
|--|--|--|--|--|--|--|--|--|
||←||←<br>HTTP응답||←<br>비지니스 응답||←<br>DB결과|

## 3. 서버 아키텍처의 구성요소
|구성 요소|설명|유형|
|--|--|--|
|운영체제|시스템 하드웨어-사용자 프로그램 사이 존재.<br> 시스템적으로 관리해주는 구성 요소|Linux, Windows 등|
|파일 서버| 파일 저장 하드웨어로 물리적 저장 장치를 활용한 서버|NAS|
|DB 서버|데이터를 저장하여 효율적으로 조회 및 사용하기 위한 서버|Oracle, Mysql, 몽고DB 등|
|웹 서버|HTTP를 통해 Web browser에서 요청하는 HTML문서나 Object를 전송해주는 서비스 및 프로그램|Apache, nginx|
|웹 애플리케이션 서버|Web Service를 Dynamic으로 제공하기 위한 WAS(Web Application Server)의 형태|WAS, Tomcat|

---
# 2. 통합 개발 환경

## 1. 통합 개발 도구
- 개발 환경 구축에는 개발할 수 있는 Hardware를 구축, 도구를 사전 세팅하는 활동이 포함
- 개발활동을 테스트하고, 배포, 모니터링 할 수 있는 기능을 제공하는 도구들이 있다.

< 세부 개발 도구 >
|tools|explain|e.g.|
|--|--|--|
|구현 도구(IDE)|개발 언어를 통해 실제 구현할 수 있는 기능 및 환경을 제공하는 도구|VS, Eclipse, IntelliJ 등|
|테스트 도구|개발된 모듈에 대해 요구 사항대로 구현됐는지 확인하는 도구|Junit, Spring Test 등|
|형상 관리 도구|개발된 것에 대해 저장하면서 버전 및 히스토리 확인 도구|Git, CVS, SVN 등|
|빌드 도구| 개발된 코드에 대해 컴파일 및 빌드할 도구|Ant, Maven, Gradle 등|

## 2. 형상관리
- 형상 관리 절차
- 식별 -> 통제 -> 감사 -> 기록 순서대로 진행
|절차|활동|설명|
|--|--|--|
|형상 식별|대상 식별|형상 관리 대상을 정의, 식별하고 해당 항목에 추적성을 부여하기 위한 ID 관리 번호를 부여하는 활동|
|형상 통제|승인, 검토 통제|변경 요구 관리, 변경 제어, 형상 관리 등 통제 지원|
|형상 감사|베이스라인 무결성|베이스라인 변경 시 요구 사항과 일치 여부 검토|
|형상 기록|각종 수행 결과 기록| 소프트웨어 형상 및 변경 관리에 대한 수행 결과 기록|

- 형상 관리 구성 요소
|구성 요소| 설명|
|--|--|
|기준선(Baseline)|- 각 형상 항목들의 기술적 통제 시점. 모든 변화를 통제하는 시점의 기준 <br> - 라이프 사이클상 진행과 변경을 구별하는 관리상의 기준점|
|형상 항목(Configuration Item)| 소프트웨어 생명주기 중 공식적으로 정의되고 관리되는 대상<br>e.g. 기술문서, 개발도구, 소스코드가 포함되는 항목
|형상물(Configuration Product)|소프트웨어 개발 생명주기 중 공식적으로 구현되는 형체가 있는 실현된 형상 관리의 대상<br>e.g. 기술 문서, 하드웨어 제품, 소프트웨어 제품|
|형상 정보(Configuration Information)|형상 정보는 형상 항목과 형상물로 구성되는 정보|
|CCB(Configuration Control Board| 형상 관리에 대한 전략과 통제 등 전반적인 관리 통제를 하는 조직<br>e.g. 전략/표준 수립, 교육, 베이스라인 설정, 변경 통제/승인, 식별, 통제, 감사, 기록 등|

## 3. 개발 환경 구축 절차

|절차|상세 설명|주요 활동|
|--|--|--|
|1. 요구 사항 분석|대상이 되는 시스템의 요구 사항을 분석하여 어떠한 도구들이 필요할 지 준비하는 과정 | 시스템 환경 분석|
|2. 도구 설계 | 구현 도구, 빌드 도구, 테스트 도구, 형상 관리 등 요구사항에 맞는 시스템 구축 위한 환경 설계|관련 도구 현황 파악|
|3. 개발 언어 선정|개발 대상에 적합한 언어 설정|언어 선정 및 기준 점검|
|4. 개발 도구 설정|언어에 따른 적합한 도구 파악|JAVA, C, Python 등에 따른 도구 선정|
|5. 빌드/테스트 구축|팀원 경험과 개발 환경에 맞는 빌드 및 테스트|CI/CD 구축|


---
# Devops
- Devops = Development + Operations
	- 개발자 - 정보기술 전문가 간의 소통, 협업 및 통합을 강조하는 개발 환경이나 문화를 의미하는 방법론
	- 협업, 가시성 및 효율 / 팀 역할 범위와 책임의 변화/ 짧은 릴리스 주기 / 지속적인 공부
- 활동
|단계|설명|
|--|--|
|코드 작성|코드 개발 및 검토, 버전관리 도구, 코드 병합|
|빌드|지속적 통합(CI) 도구, 빌드 상태|
|테스트|테스트 및 결과가 성능을 결정|
|패키지|애플리케이션 디플로이 이전 단계|
|릴리스|변경사항 관리, 릴리스 승인, 릴리스 자동화|
|구성|인프라 스트럭쳐 구성 및 관리, IaC(Infrastructure as Code) 도구
|모니터링|애플리케이션 성능 모니터링, 최종 사용자 경험|

### CD(Continuous Delivery) 와 CI(Continuous Integration)
- **CD(Continuous Delivery)**   ("배포" 활동의 핵심이 되는 활동)
	- Continuous Delivery
		- 개발자들이 애플리케이션에 적용한 변경 사항이 bug test를 거쳐 repository에 자동으로 업로드하는 활동
	- Continuous Deployment
		- 개발자의 변경 사항을 repository에서 고객이 사용 가능한 Production 환경까지 자동으로 release 하는 활동
- **CI(Countinuous Integration)**  (배포할 준비를 하는게 중점)
	- 중앙 저장소에 지속적으로 Code가 통합 / 테스트되고 배포할 준비를 하는 자동 환경 구축 방법
	- 소스코드 변경사항을 공유 branch 또는 trunk로 다시 Merge하는 작업 수행 활동
	- 자동화된 단위/통합 테스트로 변경 사항의 정확한 적용 여부, 기존 코드와 충돌 여부 등을 확인하는 활동

---
# Coding

##### 프로그래밍 언어의 유형
- 저급 언어
	- 기계어 : CPU가 직접 해독하고 실행 할 수 있는 비트 단위로 쓰인 언어
	- 어셈블리어 : 기계어와 일대일 대응이 되는 컴퓨터 프로그래밍 언어
- 고급언어
	- 베이직
		- 언어 문법이 상대적으로 쉬운 절차형 프로그래밍 언어
	- C
		- 유닉스 운영체제를 만들기 위해 개발된 프로그래밍 언어
		- 기존 어셈블리 언어의 문제점을 해결
	- Python
		- Platform이 독립적인 "객체 지향"적 대화형 프로그래밍 언어
		- Interpreter 언어로 타입이 동적으로 정해져 있다.
		- C 보다 느림
		- 오픈소스, 다양한 library 지원
		- 데이터 분석 및 머신 러닝 개발에 주로 사용
	- Java
		- "객체 지향" 적 언어
	- Ruby
		- "동적 객체 지향" 스크립트 프로그래밍 언어

##### 언어 선정 기준
- 적정성
	- 개발하고자 하는 시스템 및 응용 프로그램의 목적에 적합한가?
- 범용성
	- 다수의 시스템에서 사용중이며 과거 사례가 다양한가?
- 친밀성
	- 대중의 프로그래머가 사용 가능한 언어인가?
- 효율성
	- 개발 대상을 효율적 구현 가능?
- 이식성
	- 여러가지 Device와 OS에 적용 가능?

##### Debugging
- 테스트 자동화
	- 기능 테스트 등 테스트 도구를 사용해 자동화를 통한 테스트의 효율성을 높임
	- e.g.> xUnit, STAF, FitNesse 등
- 정적 분석
	- 코딩 표준, 런타임 오류 검증
	-  e.g.> pmd, findbug, sonar, checkstyle 등
- 동적 분석
	- 대상 System Simulation을 통한 오류 검출
	-  e.g.> Avalanch, Valgrind 등
- 성능 테스트
	- 가상 사용자를 인위적으로 생성해 시스템 처리 능력 측정
	-  e.g.> Jmeter, AB, OpenSTA 등
- 모니터링
	- System Resource (CPU, Memory ) 상태 확인 및 분석 지원 도구
	-  e.g.> Nagios, Zenoss 등

##### Compile
- 원시 코드 ---> 목적 코드 옮기는 과정
- 실행 운영체제 대상 분류
	- Native Compiler
		- 목적 코드가 실행될 컴퓨터나 운영체제가 같은 컴파일러를 이용하는 방식
	- Cross Compiler
		- 다른 운영체제서 실행되는 컴파일러 이용하는 방식
- Java
	- JVM
		- Java의 가상 Machine을 이용하는 Compile 방식
- 단계적 분류
	- 일단 구조
		- Source를 한번 리드하여 번역하는 방식의 Compiler를 이용하는 방식
	- 다단 구조
		- 여러 단계를 거쳐 번역하는 과정의 Compiler를 이용하는 방식

- Deploy : 최종 사용자에게 소프트웨어를 전달하는 과정
- Build : Source code file을 PC나 Moobile에서 실행 가능 독립 Sofrware 가공물로 변환하는 과정을 말하거나 그에 대한 결과물

---
# 객체화
- 객체화 : 실생활의 내용을 추상적으로 담아 표현하는 프로그램이 기법

##### 객체화의 구성 요소
- Class
	- 같은 종류의 집단으로 속성(attribute)과 행위(behavior)를 통해 정의
	- 객체 지향 프로그램의 기본적인 사용자 정의 데이터형
- Object (객체)
	- 실제 메모리에 할당된 Class의 구체적 instance
	- 자신 고유의 속성을 가지며 클래스에서 정의한 행위(behavior)를 수행
- Attribute (속성)
	- 객체의 데이터
- Method
	- 객체의 행위를 정의한 단위
	- 클래스로부터 생성된 객체를 사용하는 방법
- Message
	- 다른 객체에 특정 작업을 요청하는 신호로 객체들 간의 상호작용
	- 수신 객체 이름, 오퍼레이션 이름, 매개변수로 구성

##### 객체화 기법
- Abstraction(추상화)
	- 공통 성질을 추출해 super Class로 구성
	- 복잡한 현실의 세계를 객체 중심의 안정된 모델로 표현
- Encapsulation (캡슐화)
	- 관련성이 많은 속성과 메소드를 하나로 묶어서 객체로 구성
	- 사용자에게는 객체의 기능과 사용법만 제공하고 내부 처리 과정은 은닉
	- 데이터 보호, 추상화 용이, 사용성 증가, 변경 용이, 재사용성 증가
- Polymorphism (다형성)
	- 동일한 이름의 Operation을 여러 형태의 다른 사양으로 정의 가능
	- Overloading : 매개변수의 수 또는 타입을 달리하여 구분
	- Overriding : 부모 클래스의 메소드를 재정의
- Inheritance (상속)
	- 상위 클래스의 속성과 메소드를 하위 클래스가 상속받아 사용
	- 상위 클래스는 추상적(일반화)이며, 하위 클래스는 구체적(특수화) 성질을 가짐
- Information Hiding (정보 은닉)
	- Encapsulation된 항목(내부 구현)을 다른 Object로부터 숨김
	- 모듈 내 인터페이스와 구현을 분리하고 인터페이스를 통해서만 메시지 전달

##### 객체화 설계 원리   -----> Design Pattern
- SRP (Single Responsibillity Principle)
	- 단일 책임 원칙 : 객체는 하나의 책임만 진다는 원리
- OCP (Open Close Principle)
	- 개방 폐쇄 원칙 : 확장에 열리고 수정에 닫혀야 한다는 원리
- LSP (Liskov Substitution Principle)
	- 리스코프 교체 원칙 : 하위 클래스는 상위 클래스를 대체할 수 있어야 한다는 원리
- ISP (Interface Segregation Principle)
	- 인터페이스 분리 원칙 : 관련 없는 메소드는 의존하지 않는다는 원리
- DIP (Dependency Inversion Principle)
	- 의존관계 역전 원칙 : 추상화에 의존하고, 구체적인 것에 의존하지 않는다는 원리

##### JAVA의 객체 접근 제한자
- public : 모든 접근을 허용하는 제한자
- protected : 같은 패키지(폴더)에 있는 객체와 상속 관계의 객체들만 허용하는 제한자
- default : 같은 패키지(폴더)에 있는 객체들만 허용하는 제한자
- private : 현재 클래스 내에서만 허용하는 제한자

---
# 서버 프레임워크
- Framework의 개념
	- 협업의 개발이 가능하도록 공통 표준을 제시해 개발할 수 있도록 할 수 있는 도구이자 가이드
	- 인터페이스, 설정, 코드 등을 정해 재사용이 가능할 수 있도록 기능 등을 포함

##### 서버 프레임워크의 특징
- Modularity (모듈화)
	- 인터페이스에 의한 캡슐화를 통해 모듈화를 강화
	- 설계와 구현의 변경에 따르는 영향을 최소화하는 성질
- Reusability (재사용성)
	- 반복적으로 사용될 수 있는 컴포넌트를 정의해 재사용성을 높인다.
- Extensibillity (확장성)
	- 다형성을 통해 애플리케이션이 프레임워크의 인터페이스를 확장할 수 있게 한다.

##### Surver Framework 구성 요소
- 요소
	- 구성 기능
		- 세부 기능 으로 기술.

- 개발 환경
	- 구현 도구, 배포 도구, 테스트 도구, 형상 관리 도구
		- 데이터 개발 도구, 테스트 자동화 도구, 코드 검사 도구, 템플릿 프로젝트 생성 도구, 공통 컴포넌트 조립 도구, 서버 환경 관리 도구, 모바일용 표준 소스 코드 생성 도구 등 환경
- 실행 환경
	- 화면 처리, 업무 처리, 데이터 처리, 연계 통합, 공통 기반
		- 개발하는 업무 프로그램의 실행에 필요한 공통 모듈 등 업무 프로그램 개발 시 화면, 서버 프로그램, 데이터 개발, 배치 처리 기능 개발을 표준화가 용이하도록 지원하는 응용 프로그램 환경
- 운영 환경
	- 모니터링 도구, 운영 관리 도구, 배치 운영 도구
		- 실행 환경에서 운영되는 서비스를 운영하기 위한 환경 제공(모니터링, 배포, 관리 시스템 등)과 배치 환경을 운영하기 위한 환경 제공(배치 실행, 스케줄링, 결과 모니터링 등)
- 관리 환경
	- 서비스 요청 관리, 변경 관리, 현황 관리, 표준 관리
		- 개발 프레임워크 및 공통 서비스를 각 개발 프로젝트에 배포 및 관리하기 위한 모듈

##### 전자정부 프레임워크
- 전자정부 표준 프레임워크는 공공사업에 적용되는 개발 프레임워크의 표준 정립으로, 응용 SW 표준화, 품질 및 재사용성 향상을 목표로 하는 개발 프레임워크
< 특징 >
- 변화 유연성
	- 각 서비스의 모듈화로 교체가 용이, 인터페이스 기반 연동으로 모듈 변경에 대한 영향 최소화
- 국가 표준화 지향
	- 민간, 학계로 구성된 자문협의회를 통한 국가적 차원 표준화 수행
- 편리하고 다양한 환경
	- 이클립스 기반의 모델링(UML, ERD), 컴파일링, 디버깅 환경 제공
- 모바일 환경 지원
	- 모바일 환경을 위한 모바일 웹(UX / UI) 및 하이브리드 앱 지원
- 개방형 표준 준수
	- 오픈 소스 기반의 범용화되고 공개된 기술의 활용으로 특정 사업자에 대한 종속성 배제
- 상용 솔루션 연계
	- 상용 솔루션과 연계가 가능한 표준을 제시해 상호 운용성 보장

---
# Secure Coding
- 서버